= Управление индексами

Вы можете идексировать информацию, используя OpenSearch REST API. Существуют два API: index API и `_bulk` API.

В ситуациях, когда новые данные поступают постепенно (например, заказы клиентов малого бизнеса), можно использовать index API для добавления документов по отдельности по мере их поступления. В ситуациях, когда поток данных поступает реже (например, при еженедельном обновлении маркетингового веб-сайта), можно сгенерировать файл и отправить его используя `_bulk API`. При работе с большим количеством документов объединение запросов и использование _bulk API обеспечивает более высокую производительность. Однако, если документы огромны, может потребоваться проиндексировать их отдельно.

При индексировании документов размер `_id` документа должен составлять не более 512 байт.
[%hardbreaks]
== Введение в индексацию

Прежде чем вы сможете искать данные, вы должны их проиндексировать. Индексирование — это метод, с помощью которого поисковые системы систематизируют данные для быстрого поиска. Полученная структура называется индексом.

В OpenSearch основной единицей данных является документ JSON. Внутри индекса OpenSearch идентифицирует каждый документ по ID (уникальному идентификатору).

Запрос к индексному API выглядит следующим образом:
****
PUT `<index>/_doc/<id>`
[source,json]
----

{ "A JSON": "document" }
----
****

Запрос к API _bulk выглядит немного иначе, потому что вы указываете индекс и ID в общем массиве данных:

****
POST `_bulk`
[source,JSON]
----

{ "index": { "_index": "<index>", "_id": "<id>" } }
{ "A JSON": "document" }
----
****


Общий массив данных должен соответствовать определенному формату, для чего используется символ "с новой строки" (`\n`) в конце каждой строки, включая последнюю. Это основной формат:
....
Action and metadata\n
Optional document\n
Action and metadata\n
Optional document\n
....


NOTE: Документ необязателен, поскольку команду `delete` не требует наличие самого документа. Все остальные команды (`index`, `create` и `update`) требуют, чтобы документ существовал. ЕЕсли вы специально хотите, чтобы команда завершилась ошибкой, используйте команду `create` вместо команды `index` в случае, когда документ уже существует.


Чтобы проиндексировать большой объем данных с помощью команды `curl`, перейдите в папку, в которой сохранен файл, и выполните следующую команду:

[source,shell]
----
curl -H "Content-Type: application/x-ndjson" -POST https://localhost:9200/data/_bulk -u 'admin:admin' --insecure --data-binary "@data.json"
----

Если какая-либо из команд в  `_bulk` API не удается, OpenSearch продолжает выполнять другие команды. Изучите массив `items` в ответе, чтобы выяснить, что пошло не так. Записи в массиве элементов находятся в том же порядке, что и действия, указанные в запросе.

OpenSearch автоматически создает индекс, когда вы добавляете документ в индекс, который еще не существует. Он также автоматически генерирует ID, если вы не указали ID в запросе. Простой пример ниже автоматически создает индекс фильмов, индексирует документ и назначает ему ID:
****
POST `movies/_doc`
[source,JSON]
----
{ "title": "Spirited Away" }
----
****
Автоматическая генерация ID имеет явный недостаток: поскольку в запросе на индексацию не указан ID, вы не сможете легко обновить документ позже. Кроме того, если вы выполните этот запрос 10 раз, OpenSearch проиндексирует этот документ как 10 разных документов с разными ID. Чтобы указать ID, равный 1, используйте следующий запрос (обратите внимание на использование запроса PUT вместо POST):

****
PUT `movies/_doc/1`
[source,JSON]
----

{ "title": "Spirited Away" }
----
****

Поскольку вы указали ID, если вы запустите эту команду 10 раз, у вас  будет только один проиндексированный документ с полем `_version`, увеличенным до значения 10.

Индексы по умолчанию имеют один первичный независимый элемент и одну копию. Если вы хотите указать нестандартные настройки, создайте индекс перед добавлением документов:

****
PUT `more-movies`
[source,JSON]
----

{ "settings": { "number_of_shards": 6, "number_of_replicas": 2 } }
----
****
== Ограничения на именование индексов

Индексы OpenSearch имеют следующие ограничения на наименования:

Все буквы должны быть строчными.
Имена индексов не могут начинаться с подчеркиваний (`_`) или дефисов (`-`).
Имена индексов не могут содержать пробелы, запятые или следующие символы:

`:`,`"`, `*`, `+`, `/`, `\`, `|`, `?`, `#`, `>` или `<`

== Чтение данных

После индексации документа вы можете получить его, отправив запрос GET по тому же адресу, который вы использовали для индексации:

****
GET `movies/_doc/1`
[source,JSON]
----
{
  "_index" : "movies",
    "_type" : "_doc",
  "_id" : "1",
  "_version" : 1,
  "_seq_no" : 0,
  "_primary_term" : 1,
  "found" : true,
  "_source" : {
  "title" : "Spirited Away"
  }
}
----
****

Вы можете увидеть документ в объекте `_source`. Если документ не найден, то значение поля `found` равно `false`, а объект `_source` не появляется в ответе на запрос.

Чтобы получить несколько документов с помощью одной команды, используйте комагду   `_mget`. Формат для получения нескольких документов аналогичен команде  `_bulk`, где вы должны указать индекс и ID в теле запроса:
****
GET `_mget`
[source,JSON]
----
{
  "docs": [
    {
      "_index": "<index>",
      "_id": "<id>"
    },
  {
    "_index": "<index>",
    "_id": "<id>"
    }
  ]
}
----
****

Чтобы вернуть только определенные поля в документе используйте запрос:
****
GET `_mget`
[source,JSON]
----
{
    "docs": [
        {
        "_index": "<index>",
        "_id": "<id>",
        "_source": "field1"
        },
        {
        "_index": "<index>",
        "_id": "<id>",
        "_source": "field2"
        }
    ]
}
****

Команда, чтобы проверить, существует ли документ:


****
HEAD `movies/_doc/<doc-id>`
****

Если документ существует, вы получите ответ `200 OK`, а если нет, вы получите ошибку `404 - Not Found`.

== Обновление данных
Чтобы обновить существующие поля или добавить, необходимо отправить запрос POST на операцию _update с вашими изменениями в объекте `doc`:

****
POST `movies/_update/1`
[source,JSON]
----
{
    "doc": {
        "title": "Castle in the Sky",
        "genre": ["Animation", "Fantasy"]
    }
}
----
****

Обратите внимание на обновленное поле `title` и новое поле `genre`:
****
GET `movies/_doc/1`
[source,JSON]
----

{
    "_index" : "movies",
    "_type" : "_doc",
    "_id" : "1",
    "_version" : 2,
    "_seq_no" : 1,
    "_primary_term" : 1,
    "found" : true,
    "_source" : {
        "title" : "Castle in the Sky",
        "genre" : [
            "Animation",
            "Fantasy"
        ]
    }
}
****

Документ также имеет увеличенное значение поля `_version`. Использование этого поля позволяет отслеживать, сколько раз обновлялся документ.

Запросы POST выполняют частичные обновления документов. Чтобы полностью заменить документ, необходимо использовать запрос PUT:
****
PUT `movies/_doc/1`
[source,JSON]
----
{
"title": "Spirited Away"
}
****

Документ с ID 1 будет содержать только `title` заголовка, поскольку весь документ заменен на документ, индексированный в запросе PUT.

Объект `upsert` используется для обновления документов на основе того, существуют они или нет. Если документ существует, его поле меняется на `Castle in the Sky`. Если нет, OpenSearch индексирует документ в объекте `upsert`.
****
POST `movies/_update/2`
[source,JSON]
----
{
"doc": {
"title": "Castle in the Sky"
},
"upsert": {
"title": "Only Yesterday",
"genre": ["Animation", "Fantasy"],
"date": 1993
}
}
****
***Пример ответа:***
[source,JSON]
----
{
"_index" : "movies",
"_type" : "_doc",
"_id" : "2",
"_version" : 2,
"result" : "updated",
"_shards" : {
"total" : 2,
"successful" : 1,
"failed" : 0
},
"_seq_no" : 3,
"_primary_term" : 1
}
----

Каждая операция обновления для документа имеет уникальную комбинацию значений `_seq_no` и `_primary_term`.

OpenSearch сначала записывает ваши обновления в основной шард, а затем отправляет это изменение во все копии шардов. Проблема может возникнуть, если несколько пользователей вашего приложения на основе OpenSearch вносят обновления в существующие документы в одном индексе. В этой ситуации другой пользователь может прочитать и обновить документ из копии, прежде чем он получит ваше обновление из основного шарда. Затем ваша операция обновления в конечном итоге приводит к обновлению старой версии документа. В лучшем случае вы и другой пользователь вносите одинаковые изменения, и документ остается идентичным. В худшем случае документ будет содержать устаревшую информацию.

Чтобы предотвратить эту ситуацию, необходимо использовать значения `_seq_no` и `_primary_term` в заголовке запроса:

****
POST `movies/_update/2?if_seq_no=3&if_primary_term=1`
[source,JSON]
----
{
"doc": {
"title": "Castle in the Sky",
"genre": ["Animation", "Fantasy"]
}
}
****

Если документ обновляется после того, как мы его извлекли, значения `_seq_no` и `primary_term` различаются, и наша операция обновления завершается ошибкой `409 — Conflict`.

При использовании API `_bulk` указывайте значения `_seq_no` и `_primary_term` в метаданных действия.

== Удаление данных

Чтобы удалить документ из индекса, используйте запрос DELETE:

****
DELETE `movies/_doc/1`
****

Операция DELETE увеличивает значение поля `_version`. Если вы добавляете документ обратно к тому же идентификатору, значение поля `_version` снова увеличивается. Это происходит потому, что OpenSearch удаляет документ `_source`, но сохраняет его метаданные.

Добавление новой строкиы